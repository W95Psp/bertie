use std::{
    net::{TcpStream, ToSocketAddrs},
    time::Duration,
};

use simple_https_client::{tls13client, tls13client_continue, ClientError};
use tracing::info;

// Custom list generated by using Tranco account.
const TRANCO: (&str, &str) = ("tranco-list.eu", "/download/VXJ4N/500");

enum Outcome {
    // Test was successful.
    Success,
    // Test failed due to acceptable reasons, e.g., network error, timeout, DNS, etc.
    Acceptable,
    // Test failed due to unacceptable reasons, i.e., due to TLS errors.
    Failed,
}

#[test]
#[ignore = "This test should not run automatically."]
fn test_tranco_500_ephemeral() {
    tracing_subscriber::fmt::init();

    let tranco = {
        let response = String::from_utf8(download_tranco_500()).unwrap();
        let (_, body) = response.split_once("\r\n\r\n").unwrap();

        body.to_string()
    };

    test_tranco(&tranco);
}

fn download_tranco_500() -> Vec<u8> {
    let request = format!(
        "GET {} HTTP/1.1\r\nHost: {}\r\nConnection: Close\r\n\r\n",
        TRANCO.1, TRANCO.0
    );

    let mut out = Vec::new();

    let stream = {
        let addr = (TRANCO.0, 443).to_socket_addrs().unwrap().next().unwrap();
        TcpStream::connect_timeout(&addr, Duration::from_secs(1)).unwrap()
    };

    let (stream, cstate, chunk) = tls13client(TRANCO.0, stream, &request).unwrap();

    println!("{}", std::str::from_utf8(&chunk).unwrap());
    out.extend(chunk);

    let mut stream = stream;
    let mut cstate = cstate;
    loop {
        let (stream_new, cstate_new, chunk) = tls13client_continue(stream, cstate).unwrap();
        stream = stream_new;
        cstate = cstate_new;

        println!("----------------");
        println!("{}", std::str::from_utf8(&chunk).unwrap());
        out.extend(chunk);
    }
}

#[test]
#[ignore = "This test should not run automatically."]
fn test_tranco_500_static() {
    tracing_subscriber::fmt::init();

    let tranco = std::fs::read_to_string("tests/assets/tranco_VXJ4N.csv").unwrap();

    test_tranco(&tranco);
}

fn test_tranco(tranco: &str) {
    let mut success = 0;
    let mut acceptable = 0;
    let mut failed = 0;

    for line in tranco.lines() {
        let (index, domain) = line.split_once(",").unwrap();

        let request = format!("GET / HTTP/1.1\r\nHost: {}\r\n\r\n", domain);

        println!(
            "--------------------------------------------------------------------------------"
        );
        println!("# Testing \"{}\" ({})", domain, index);
        match https_get(domain, &request) {
            Outcome::Success => {
                success += 1;
                println!("--> Success");
            }
            Outcome::Acceptable => {
                acceptable += 1;
                println!("--> Acceptable");
            }
            Outcome::Failed => {
                failed += 1;
                println!("--> Failed");
            }
        }
    }

    println!("--------------------------------------------------------------------------------");
    info!(%success, %acceptable, %failed, "Tested {} domains.", success + acceptable + failed);

    assert_eq!(failed, 0);
}

fn https_get(domain: &str, request: &str) -> Outcome {
    let mut additional_retries = 2;

    loop {
        let stream = {
            let addr = match (domain, 443).to_socket_addrs() {
                Ok(mut addrs) => {
                    if let Some(addr) = addrs.next() {
                        addr
                    } else {
                        return Outcome::Acceptable;
                    }
                }
                Err(_) => {
                    return Outcome::Acceptable;
                }
            };

            match TcpStream::connect_timeout(&addr, Duration::from_secs(1)) {
                Ok(stream) => stream,
                Err(_) => {
                    return Outcome::Acceptable;
                }
            }
        };

        match tls13client(domain, stream, &request) {
            Ok(_) => {
                break Outcome::Success;
            }
            Err(error) => match error {
                ClientError::Io(_) => {
                    if additional_retries == 0 {
                        break Outcome::Acceptable;
                    } else {
                        info!(%additional_retries, "Retrying due to I/O error.");
                        additional_retries -= 1;
                    }
                }
                ClientError::TLS(_) => {
                    break Outcome::Failed;
                }
            },
        }
    }
}
